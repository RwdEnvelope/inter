import sys
from pathlib import Path
sys.path.append(str(Path(__file__).resolve().parent.parent))
import sounddevice as sd
import soundfile as sf
import numpy as np
import threading
import queue
import time
import json
from pathlib import Path
from datetime import datetime
import keyboard
from recoder.audio_capture import *
from agents.audio_agent import *


# === å‚æ•° ===
AUDIO_SR = 16000
CHUNK_DURATION = 5
AUDIO_FRAME_COUNT = AUDIO_SR * CHUNK_DURATION

# === æ§åˆ¶ ===
exit_flag = threading.Event()
audio_buffer = queue.Queue()
recording_threads = []
# === åˆ›å»ºè¾“å‡ºè·¯å¾„ ===
timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
audio_dir = Path(f"output/{timestamp}/video")
audio_dir.mkdir(parents=True, exist_ok=True)

# === éŸ³é¢‘åˆ†æçº¿ç¨‹ ===
def audio_consumer_worker(audio_buffer, output_dir):
    print("[åˆ†æçº¿ç¨‹] å¯åŠ¨")
    graph = build_audio_graph()
    transcripts = []
    analyses = []

    while True:
        try:
            audio_path = audio_buffer.get(timeout=1)
            if audio_path == "DONE":
                print("[åˆ†æçº¿ç¨‹] æ”¶åˆ°ç»“æŸæ ‡å¿—")
                break

            print(f"[åˆ†æçº¿ç¨‹] å¤„ç†ï¼š{audio_path}")
            result = graph.invoke({"audio_path": audio_path})
            transcripts.append({
                "audio_path": audio_path,
                "transcript": result.get("transcript", "")
            })
            analyses.append({
                "audio_path": audio_path,
                "audio_analysis": result.get("audio_analysis", {})
            })
        except queue.Empty:
            if exit_flag.is_set():
                break
            else:
                continue


    # å†™å…¥ JSON æ–‡ä»¶
    with open(output_dir / "transcripts.json", "w", encoding="utf-8") as f:
        json.dump(transcripts, f, ensure_ascii=False, indent=2)

    with open(output_dir / "audio_analysis.json", "w", encoding="utf-8") as f:
        json.dump(analyses, f, ensure_ascii=False, indent=2)

    print("[åˆ†æçº¿ç¨‹] ç»“æŸ")


# === å¤–éƒ¨æ§åˆ¶æ¥å£ ===
def start_recording():
    exit_flag.clear()
    print("ğŸ™ï¸ å¼€å§‹å½•éŸ³...")
    audio_thread = threading.Thread(target=audio_stream_worker, args=(audio_buffer, AUDIO_FRAME_COUNT, audio_dir))
    analysis_thread = threading.Thread(target=audio_consumer_worker, args=(audio_buffer, audio_dir))
    audio_thread.start()
    analysis_thread.start()
    recording_threads.extend([audio_thread, analysis_thread])

def stop_recording():
    print("ğŸ›‘ æ”¶åˆ°å‰ç«¯é€€å‡ºä¿¡å·ï¼Œæ­£åœ¨ç»ˆæ­¢...")
    wait_for_exit()
    print(f"âœ… å½•éŸ³åˆ†æç»“æŸï¼Œç»“æœå·²ä¿å­˜è‡³ï¼š{audio_dir}")
